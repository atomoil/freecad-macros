# -*- coding: utf-8 -*-

import FreeCAD
import Part
import math


baseHeight = 1.75


cutterLayers = { 'bases': [], 'inners': [], 'outers': [] }
holderLayers = { 'bases': [], 'inners': [], 'outers': [] }


basePlate = App.ActiveDocument.addObject("Part::Box","HolderBase")
basePlate.Label = "Base Plate"
basePlate.Height = str(baseHeight) + ' mm'
basePlate.Length = '100 mm'
basePlate.Width = '100 mm'
holderLayers['bases'].append(basePlate)

def addCutterPart (x, y, size, lineWidth, addTo):

	# lineWidth = 0.1
	# size = 5

	cutterHeight = baseHeight + 12

	outerSize = size
	outerSupportSize = size + 0.5
	outerSupportSize2 = size + 0.25
	innerSize = size-(lineWidth*2)

	outer = App.ActiveDocument.addObject("Part::Cylinder","Outer")
	outer.Radius = str(outerSize) + ' mm'
	outer.Height = str(cutterHeight) + ' mm'

	outerSupport1 = App.ActiveDocument.addObject("Part::Cylinder","OuterSupportLow")
	outerSupport1.Radius = str(outerSupportSize) + ' mm'
	outerSupport1.Height = str(baseHeight+1.0) + ' mm'

	outerSupport2 = App.ActiveDocument.addObject("Part::Cylinder","OuterSupportHigh")
	outerSupport2.Radius = str(outerSupportSize2) + ' mm'
	outerSupport2.Height = str(baseHeight+2.0) + ' mm'

	inner = App.ActiveDocument.addObject("Part::Cylinder","Inner")
	inner.Radius = str(innerSize) + ' mm'
	inner.Height = '20 mm'

	placement = App.Placement(App.Vector(x,y,0),App.Rotation(App.Vector(0,0,1),1))

	inner.Placement = placement
	outer.Placement = placement
	outerSupport1.Placement = placement
	outerSupport2.Placement = placement

	addTo['inners'].append(inner)
	addTo['outers'].append(outer)
	addTo['outers'].append(outerSupport1)
	addTo['outers'].append(outerSupport2)


def addBaseHolePart (x, y, size, lineWidth, addTo):

	innerSize = size + 0.5

	inner = App.ActiveDocument.addObject("Part::Cylinder","InnerBaseHole")
	inner.Radius = str(innerSize) + ' mm'
	inner.Height = '5 mm'

	inner.Placement = App.Placement(App.Vector(x,y,0),App.Rotation(App.Vector(0,0,1),1))

	addTo['inners'].append(inner)


def createBoxViaSketcher(x,y,angle,distance,nearRadius,farRadius,addTo):

	sketch = App.activeDocument().addObject('Sketcher::SketchObject', 'BaseSketch')

	nearL = trig(x,y,angle-90,nearRadius)
	nearR = trig(x,y,angle+90,nearRadius)
	(farX, farY) = trig(x,y,angle,distance)
	farL = trig(farX,farY,angle-90,farRadius)
	farR = trig(farX,farY,angle+90,farRadius)

	edges = [nearL, farL, farR, nearR]
	countPoints = len(edges)

	geoList = []
	for i in range(countPoints):
		j = i+1
		if j >= countPoints:
			j = 0

		(x1, y1) = edges[i]
		(x2, y2) = edges[j]
		pt1 = App.Vector(x1,y1)
		pt2 = App.Vector(x2,y2)
		line = Part.LineSegment(pt1,pt2)
		geoList.append(line)

	sketch.addGeometry(geoList,False)
	extrude = App.activeDocument().addObject('Part::Extrusion','ExtrudedBaseSketch')
	extrude.Base = sketch
	extrude.Solid = True
	extrude.LengthFwd = baseHeight

	# stop rendering the sketch as it doesn't hide properly
	sketch.Visibility = False

	addTo['bases'].append(extrude)
	
	# extrude.DirMode = "Normal"
	# extrude.DirLink = None
	# extrude.LengthFwd = 10.000000000000000
	# extrude.LengthRev = 0.000000000000000
	# 
	# extrude.Reversed = False
	# extrude.Symmetric = False
	# extrude.TaperAngle = 0.000000000000000
	# extrude.TaperAngleRev = 0.000000000000000


def createPerpendicularBase(x,y,w,h,addTo):
	sketch = App.activeDocument().addObject('Sketcher::SketchObject', 'BaseSketch')

	nearL = (x,y)
	nearR = (x+w,y) 
	farL = (x,y+h)
	farR = (x+w,y+h)

	edges = [nearL, farL, farR, nearR]
	countPoints = len(edges)

	geoList = []
	for i in range(countPoints):
		j = i+1
		if j >= countPoints:
			j = 0

		(x1, y1) = edges[i]
		(x2, y2) = edges[j]
		pt1 = App.Vector(x1,y1)
		pt2 = App.Vector(x2,y2)
		line = Part.LineSegment(pt1,pt2)
		geoList.append(line)

	sketch.addGeometry(geoList,False)
	extrude = App.activeDocument().addObject('Part::Extrusion','PerpBase')
	extrude.Base = sketch
	extrude.Solid = True
	extrude.LengthFwd = baseHeight

	# stop rendering the sketch as it doesn't hide properly
	sketch.Visibility = False

	addTo['bases'].append(extrude)


def groupHolesIntoStencil(addTo, name):

	# group the shapes
	if len(addTo['bases']) > 1:
		baseGroup = App.ActiveDocument.addObject("Part::MultiFuse", "BaseFuse")
		baseGroup.Shapes = addTo['bases']
		addTo['outers'].append( baseGroup )
	elif len(addTo['bases']) == 1:
		addTo['outers'].append( addTo['bases'][0] )

	innerGroup = App.ActiveDocument.addObject("Part::MultiFuse", "InnerFuse")
	innerGroup.Shapes = addTo['inners']

	if len(addTo['outers']) > 1:
		outerGroup = App.ActiveDocument.addObject("Part::MultiFuse", "OuterFuse")
		outerGroup.Shapes = addTo['outers']
	elif len(addTo['outers']) == 1:
		outerGroup = addTo['outers'][0]

	# Cut the inner from the outer into the final stencil
	stencil = App.activeDocument().addObject("Part::Cut",name)
	stencil.Base = outerGroup
	stencil.Tool = innerGroup


def trig(x, y, angle, distance):
	theta = math.radians(angle+90)
	x = x + (math.sin(theta) * distance)
	y = y + (math.cos(theta) * distance)
	return (x,y)


def createGridOfHoles(mx, my, holeSize, gridSize):

	basePlate = App.ActiveDocument.addObject("Part::Box","HolderBase")
	basePlate.Label = "Base Plate"
	basePlate.Height = str(baseHeight) + ' mm'
	cutterLayers['bases'].append(basePlate)

	# gridSize = holeSize
	# holeSize = 4
	# mx = 10
	# my = 10
	for x in range(mx):
		for y in range(my):
			nx = gridSize + (x*gridSize*2)
			ny = gridSize + (y*gridSize*2)
			size = (((math.sin(x+(y/2))+1)/2) * (holeSize*0.5)) + (holeSize*0.5)
			addCutterPart(nx, ny, size, 0.25, cutterLayers)
			addBaseHolePart(nx, ny, size, 0.25, holderLayers)

	basePlate.Length = str(mx*gridSize*2)
	basePlate.Width = str(my*gridSize*2)



def createCircleOfHoles():
	ox = 50
	oy = 50
	distance = 10
	total = 30
	angle = 360/(total/3)
	for i in range(0,total):
		distance = 10 + (i * 1.1)
		(x, y) = trig(ox,oy,angle*i,distance)
		addCutterPart(x, y, 3+(0.2*i), 0.25, cutterLayers)


def createLineOfHoles(ox,oy,angle,distance,total):
	margin = 2
	holeSize = (distance/total)/2 - margin
	for i in range(0,total):
		thisDistance = i * (distance/(total-1))
		thisHoleSize = (holeSize*0.6) + ((holeSize*0.4)*(i/total))
		(x,y) = trig(ox,oy,angle,thisDistance)
		addCutterPart(x,y,thisHoleSize,0.25,cutterLayers)
		addBaseHolePart(x,y,thisHoleSize, 0.25, holderLayers)

	createBoxViaSketcher(ox,oy,angle,distance,holeSize*0.6,holeSize, cutterLayers)


def createFan():
	cx = 10
	cy = 95
	distanceInner = 200
	distanceMiddle = 175
	distanceOuter = 150

	createLineOfHoles(cx,cy+60,-12,distanceOuter,12)
	createLineOfHoles(cx+5,cy+50,-10.3,distanceOuter-5,8)
	createLineOfHoles(cx,cy+40,-8,distanceMiddle,14)
	createLineOfHoles(cx+5,cy+30,-6.25,distanceMiddle-5,10)
	createLineOfHoles(cx,cy+20,-4,distanceInner,16)
	createLineOfHoles(cx+7,cy+10,-2.5,distanceInner-7,10)
	createLineOfHoles(cx,cy,0, distanceInner,13)
	createLineOfHoles(cx+7,cy-10,2.5,distanceInner-7,10)
	createLineOfHoles(cx,cy-20,4,distanceInner,16)
	createLineOfHoles(cx+5,cy-30,6.25,distanceMiddle-5,10)
	createLineOfHoles(cx,cy-40,8,distanceMiddle,14)
	createLineOfHoles(cx+5,cy-50,10.3,distanceOuter-5,8)
	createLineOfHoles(cx,cy-60,12,distanceOuter,12)

	createPerpendicularBase(cx,cy-60,8,120,cutterLayers)
	createPerpendicularBase(cx+(distanceOuter/2)-8,cy-80,8,160,cutterLayers)

	createPerpendicularBase(cx+distanceOuter-8,cy-90,8,180,cutterLayers) # TODO: calculate the position of far end
	createPerpendicularBase(cx+distanceMiddle-8,cy-65,8,130,cutterLayers)
	createPerpendicularBase(cx+distanceInner-8,cy-35,8,70,cutterLayers)



# createGridOfHoles(5,5,4,5)
# createGridOfHoles(6,5,4,5)
# createCircleOfHoles()
# createBoxViaSketcher()
# createLineOfHoles(0,0,0,100,5)
# createLineOfHoles(0,40,5,120,8)
createFan()
groupHolesIntoStencil(cutterLayers, "Stencil")
groupHolesIntoStencil(holderLayers, "Holder")
